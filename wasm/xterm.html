<!doctype html>
<html>
<!--
  xterm.js based interactive REPL for grol.
  Uses globalThis.fs overrides to bridge stdin/stdout/stderr between
  the Go WASM runtime and xterm.js. The Go side uses x/term.Terminal
  for line editing (ANSI escape sequences), which xterm.js renders.

  Keep grol/wasm/xterm.html and web-site/_includes/xterm.html in sync.
  make wasm to test changes.
-->

<head>
    <meta charset="utf-8">
    <title>Grol REPL</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5/css/xterm.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1e1e1e;
            color: #ccc;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #header {
            padding: 8px 12px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        #header a {
            color: #6cb6ff;
            text-decoration: none;
        }

        #header a:hover {
            text-decoration: underline;
        }

        #version {
            color: #888;
            font-size: 13px;
        }

        #status {
            color: #888;
            font-size: 13px;
            margin-left: auto;
        }

        #image-container {
            display: none;
            padding: 8px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            text-align: center;
            flex-shrink: 0;
            position: relative;
        }

        #image-container img {
            max-width: 100%;
            max-height: 300px;
        }

        #close-image {
            position: absolute;
            top: 4px;
            right: 8px;
            cursor: pointer;
            color: #888;
            font-size: 18px;
            background: none;
            border: none;
        }

        #close-image:hover {
            color: #fff;
        }

        #terminal-container {
            flex: 1;
            padding: 4px;
            overflow: hidden;
        }

        .xterm {
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="header">
        <span id="version">Loading GROL...</span>
        <a href="/index.html">Textarea</a> mode
        <a href="/ghostty.html">ghostty-web</a> mode
        <span id="status"></span>
    </div>
    <div id="image-container">
        <button id="close-image" onclick="closeImage()">&times;</button>
        <img id="image" src="" alt="Image output">
    </div>
    <div id="terminal-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0/lib/addon-fit.js"></script>
    <script src="/wasm_exec.js"></script>
    <script>
        // â”€â”€â”€ xterm.js Terminal Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const xterm = new Terminal({
            cursorBlink: true,
            fontSize: 15,
            fontFamily: '"Cascadia Code", "Fira Code", "JetBrains Mono", Menlo, Monaco, "Courier New", monospace',
            theme: {
                background: '#1e1e1e',
                foreground: '#d4d4d4',
                cursor: '#d4d4d4',
                selectionBackground: '#264f78',
            },
            convertEol: false,  // We handle \r\n ourselves (x/term.Terminal does CRLF)
            allowProposedApi: true,
        });

        const fitAddon = new FitAddon.FitAddon();
        xterm.loadAddon(fitAddon);
        xterm.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        // Set terminal globals for fortio.org/terminal WASM detection.
        // These must be set before go.run() so IsTerminal() returns true.
        globalThis.TerminalConnected = true;
        globalThis.TerminalCols = xterm.cols;
        globalThis.TerminalRows = xterm.rows;

        window.addEventListener('resize', () => {
            fitAddon.fit();
            // Update globals for fortio.org/terminal's platformGetSize
            globalThis.TerminalCols = xterm.cols;
            globalThis.TerminalRows = xterm.rows;
            // Also notify Go directly if the function is registered
            if (typeof grolSetTermSize === 'function') {
                grolSetTermSize(xterm.cols, xterm.rows);
            }
        });

        function closeImage() {
            document.getElementById('image-container').style.display = 'none';
            fitAddon.fit();
        }

        // â”€â”€â”€ localStorage-backed Virtual Filesystem â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        //
        // Go WASM uses globalThis.fs for all file I/O (via wasm_exec.js).
        // We provide a minimal in-memory filesystem backed by localStorage
        // so that REPL history (~/.grol_history) and state (.gr) persist
        // across browser sessions. Files are stored as localStorage keys
        // prefixed with "grol:vfs:".
        //
        // Also bridges stdin/stdout/stderr:
        //   - os.Stdout (fd=1) â†’ xterm.write()
        //   - os.Stderr (fd=2) â†’ xterm.write()
        //   - os.Stdin  (fd=0) â† xterm.onData()

        // Set proper POSIX fs.constants (wasm_exec.js defaults them to -1).
        // Go's syscall/fs_js.go reads these at init time to map Go flags
        // (O_WRONLY, O_CREATE, etc.) to the values passed to fs.open().
        globalThis.fs.constants = {
            O_RDONLY:    0,
            O_WRONLY:    1,
            O_RDWR:     2,
            O_CREAT:    0o100,
            O_EXCL:     0o200,
            O_TRUNC:    0o1000,
            O_APPEND:   0o2000,
            O_DIRECTORY: 0o200000,
        };

        // â”€â”€â”€ Virtual File System (localStorage-backed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const VFS_PREFIX = "grol:vfs:";
        const S_IFREG = 0o100000;

        // In-memory file store: path â†’ content string
        // Loaded from localStorage on open, saved back on close.
        const vfsFiles = {};    // path â†’ string content
        const vfsOpenFDs = {};  // fd â†’ { path, pos, flags, data (Uint8Array) }
        let vfsNextFD = 10;     // start above stdin/stdout/stderr

        function vfsLoad(path) {
            const key = VFS_PREFIX + path;
            const data = localStorage.getItem(key);
            if (data !== null) {
                vfsFiles[path] = data;
                return true;
            }
            return path in vfsFiles;
        }

        function vfsSave(path) {
            const key = VFS_PREFIX + path;
            if (path in vfsFiles) {
                localStorage.setItem(key, vfsFiles[path]);
            }
        }

        function vfsDelete(path) {
            delete vfsFiles[path];
            localStorage.removeItem(VFS_PREFIX + path);
        }

        // Normalize paths: strip leading "./", resolve "path.resolve" quirks
        function vfsNormalize(p) {
            if (typeof p !== 'string') return p;
            // Remove leading ./
            while (p.startsWith('./')) p = p.substring(2);
            // Remove leading /
            while (p.startsWith('/')) p = p.substring(1);
            return p;
        }

        function vfsMakeStat(path, isDir) {
            const content = vfsFiles[path] || '';
            const size = isDir ? 0 : textEncoder.encode(content).length;
            const ms = Date.now();
            return {
                dev: 0, ino: 0,
                mode: isDir ? (0o40000 | 0o755) : (S_IFREG | 0o644),
                nlink: 1, uid: 0, gid: 0, rdev: 0,
                size: size,
                blksize: 4096, blocks: Math.ceil(size / 512),
                atimeMs: ms, mtimeMs: ms, ctimeMs: ms,
                isDirectory() { return isDir; },
            };
        }

        // Override fs.open
        const origFsOpen = globalThis.fs.open.bind(globalThis.fs);
        globalThis.fs.open = function(path, flags, mode, callback) {
            path = vfsNormalize(path);
            const O = globalThis.fs.constants;
            const accessMode = flags & 3; // O_RDONLY=0, O_WRONLY=1, O_RDWR=2
            const creating = (flags & O.O_CREAT) !== 0;
            const truncating = (flags & O.O_TRUNC) !== 0;
            const exclusive = (flags & O.O_EXCL) !== 0;
            const appending = (flags & O.O_APPEND) !== 0;

            const exists = vfsLoad(path);

            if (exclusive && exists) {
                const err = new Error('EEXIST: file already exists, open \'' + path + '\'');
                err.code = 'EEXIST';
                callback(err);
                return;
            }
            if (!exists && !creating) {
                const err = new Error('ENOENT: no such file or directory, open \'' + path + '\'');
                err.code = 'ENOENT';
                callback(err);
                return;
            }
            if (!exists) {
                vfsFiles[path] = '';
            }
            if (truncating) {
                vfsFiles[path] = '';
            }

            const fd = vfsNextFD++;
            const content = vfsFiles[path] || '';
            const data = textEncoder.encode(content);
            vfsOpenFDs[fd] = {
                path: path,
                pos: appending ? data.length : 0,
                flags: flags,
                data: data,  // snapshot for reading
                written: [],  // accumulated write buffers
                dirty: false,
            };
            callback(null, fd);
        };

        // Override fs.close
        const origFsClose = globalThis.fs.close.bind(globalThis.fs);
        globalThis.fs.close = function(fd, callback) {
            const file = vfsOpenFDs[fd];
            if (!file) {
                origFsClose(fd, callback);
                return;
            }
            // If written, assemble final content and persist
            if (file.dirty) {
                // Reconstruct content from written chunks
                const totalLen = file.written.reduce((s, b) => s + b.length, 0);
                const merged = new Uint8Array(totalLen);
                let off = 0;
                for (const chunk of file.written) {
                    merged.set(chunk, off);
                    off += chunk.length;
                }
                vfsFiles[file.path] = textDecoder.decode(merged);
                vfsSave(file.path);
            }
            delete vfsOpenFDs[fd];
            callback(null);
        };

        // Override fs.stat (path-based)
        const origFsStat = globalThis.fs.stat.bind(globalThis.fs);
        globalThis.fs.stat = function(path, callback) {
            path = vfsNormalize(path);
            // "." is the virtual current directory
            if (path === '' || path === '.') {
                callback(null, vfsMakeStat('.', true));
                return;
            }
            if (vfsLoad(path)) {
                callback(null, vfsMakeStat(path, false));
                return;
            }
            origFsStat(path, callback);
        };

        // Override fs.mkdir - allow creating "." (it already exists)
        const origFsMkdir = globalThis.fs.mkdir.bind(globalThis.fs);
        globalThis.fs.mkdir = function(path, perm, callback) {
            path = vfsNormalize(path);
            if (path === '' || path === '.') {
                callback(null);
                return;
            }
            // For any other path, just succeed (flat filesystem)
            callback(null);
        };

        // Override fs.rename
        const origFsRename = globalThis.fs.rename.bind(globalThis.fs);
        globalThis.fs.rename = function(from, to, callback) {
            from = vfsNormalize(from);
            to = vfsNormalize(to);
            if (from in vfsFiles) {
                vfsFiles[to] = vfsFiles[from];
                vfsSave(to);
                vfsDelete(from);
                callback(null);
                return;
            }
            origFsRename(from, to, callback);
        };

        // Override fs.unlink
        const origFsUnlink = globalThis.fs.unlink.bind(globalThis.fs);
        globalThis.fs.unlink = function(path, callback) {
            path = vfsNormalize(path);
            if (path in vfsFiles) {
                vfsDelete(path);
                callback(null);
                return;
            }
            origFsUnlink(path, callback);
        };

        // â”€â”€â”€ STDIN/STDOUT/STDERR Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        //
        // This lets x/term.Terminal (Go's line editor) work transparently:
        //   - It reads raw keystrokes from os.Stdin
        //   - It writes ANSI escape sequences to os.Stdout
        //   - xterm.js renders the escape sequences (cursor movement, etc.)

        // Stdin buffer: xterm.js onData â†’ stdinBuf; Go fs.read(0) â† stdinBuf
        let stdinBuf = new Uint8Array(0);
        let pendingRead = null;  // {buffer, offset, length, callback} when Go is waiting for input

        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();

        function concatBytes(a, b) {
            const c = new Uint8Array(a.length + b.length);
            c.set(a, 0);
            c.set(b, a.length);
            return c;
        }

        // Feed raw bytes from xterm.js into the stdin buffer.
        // If Go is blocked on fs.read(0), immediately fulfill it.
        function feedStdin(data) {
            const encoded = textEncoder.encode(data);

            if (pendingRead) {
                const { buffer, offset, length, callback } = pendingRead;
                pendingRead = null;

                const n = Math.min(encoded.length, length);
                buffer.set(encoded.subarray(0, n), offset);

                // Buffer any leftover
                if (encoded.length > n) {
                    stdinBuf = concatBytes(stdinBuf, encoded.subarray(n));
                }

                // Resume the blocked Go goroutine
                callback(null, n);
            } else {
                // No pending read, buffer for later
                stdinBuf = concatBytes(stdinBuf, encoded);
            }
        }

        // Save originals before overriding
        const origFsRead = globalThis.fs.read.bind(globalThis.fs);
        const origFsWrite = globalThis.fs.write.bind(globalThis.fs);
        const origFsWriteSync = globalThis.fs.writeSync.bind(globalThis.fs);

        // Override fs.fstat: make fd 0,1,2 report as character devices,
        // and support fstat on virtual file descriptors.
        const origFsFstat = globalThis.fs.fstat.bind(globalThis.fs);
        const S_IFCHR = 0o20000;
        const charDevMode = S_IFCHR | 0o620;
        globalThis.fs.fstat = function(fd, callback) {
            if (fd <= 2) {
                // Character device for stdin/stdout/stderr so
                // log.ConsoleLogging() returns true (checks ModeCharDevice).
                const ms = Date.now();
                callback(null, {
                    dev: 0, ino: 0, mode: charDevMode, nlink: 1,
                    uid: 0, gid: 0, rdev: 0, size: 0,
                    blksize: 4096, blocks: 0,
                    atimeMs: ms, mtimeMs: ms, ctimeMs: ms,
                    isDirectory() { return false; },
                });
                return;
            }
            // Virtual file descriptors
            const file = vfsOpenFDs[fd];
            if (file) {
                callback(null, vfsMakeStat(file.path, false));
                return;
            }
            origFsFstat(fd, callback);
        };

        // Override fs.read: bridge fd=0 (stdin) to xterm.js input buffer,
        // and support reading from virtual file descriptors.
        globalThis.fs.read = function(fd, buffer, offset, length, position, callback) {
            // Virtual file descriptors
            const file = vfsOpenFDs[fd];
            if (file) {
                const readPos = (position !== null && position !== undefined) ? position : file.pos;
                const remaining = file.data.length - readPos;
                if (remaining <= 0) {
                    callback(null, 0);  // EOF
                    return;
                }
                const n = Math.min(remaining, length);
                buffer.set(file.data.subarray(readPos, readPos + n), offset);
                if (position === null || position === undefined) {
                    file.pos += n;
                }
                callback(null, n);
                return;
            }

            if (fd !== 0) {
                origFsRead(fd, buffer, offset, length, position, callback);
                return;
            }

            // stdin
            if (stdinBuf.length > 0) {
                const n = Math.min(stdinBuf.length, length);
                buffer.set(stdinBuf.subarray(0, n), offset);
                stdinBuf = stdinBuf.subarray(n);
                if (stdinBuf.length === 0) stdinBuf = new Uint8Array(0);
                callback(null, n);
            } else {
                pendingRead = { buffer, offset, length, callback };
            }
        };

        // Override fs.writeSync: bridge fd=1,2 (stdout/stderr) to xterm.js
        globalThis.fs.writeSync = function(fd, buf) {
            if (fd === 1 || fd === 2) {
                const text = textDecoder.decode(buf);
                // x/term.Terminal already sends \r\n, but other Go code (log, fmt.Println)
                // may only send \n. We normalize: replace bare \n with \r\n.
                // This regex leaves existing \r\n unchanged.
                // Check for data: URL images in output â€” suppress the huge
                // base64 string and show a short colored placeholder instead.
                if (text.startsWith('data:image/')) {
                    const nl = text.indexOf('\n');
                    const dataUrl = nl >= 0 ? text.substring(0, nl) : text;
                    document.getElementById('image').src = dataUrl;
                    document.getElementById('image-container').style.display = 'block';
                    fitAddon.fit();
                    // Show a brief colored marker instead of kilobytes of base64
                    const kb = Math.round(dataUrl.length / 1024);
                    const label = '\x1b[36mðŸ“·[image ' + kb + ' KB]\x1b[0m\n';
                    const rest = nl >= 0 ? text.substring(nl) : '';
                    const replacement = label + rest;
                    const normalized = replacement.replace(/([^\r])\n/g, '$1\r\n').replace(/^\n/, '\r\n');
                    xterm.write(normalized);
                    return buf.length;
                }

                const normalized = text.replace(/([^\r])\n/g, '$1\r\n').replace(/^\n/, '\r\n');
                xterm.write(normalized);

                return buf.length;
            }
            return origFsWriteSync(fd, buf);
        };

        // Override fs.write (async version used by Go runtime)
        globalThis.fs.write = function(fd, buf, offset, length, position, callback) {
            if (fd === 1 || fd === 2) {
                if (offset !== 0 || length !== buf.length || position !== null) {
                    callback(new Error("unsupported write parameters"), 0);
                    return;
                }
                const n = this.writeSync(fd, buf);
                callback(null, n);
                return;
            }
            // Virtual file descriptors
            const file = vfsOpenFDs[fd];
            if (file) {
                const chunk = new Uint8Array(buf.buffer, buf.byteOffset + offset, length);
                file.written.push(chunk.slice());  // copy the data
                file.dirty = true;
                file.pos += length;
                callback(null, length);
                return;
            }
            origFsWrite(fd, buf, offset, length, position, callback);
        };

        // â”€â”€â”€ xterm.js Input â†’ Go stdin â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // xterm.js onData sends raw keystrokes (including ANSI escape
        // sequences for arrow keys, etc.) â€” exactly what x/term.Terminal
        // expects. No JS-side line editing needed!
        xterm.onData(data => {
            feedStdin(data);
        });

        // â”€â”€â”€ WASM Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (!WebAssembly.instantiateStreaming) {
            WebAssembly.instantiateStreaming = async (resp, importObject) => {
                const source = await (await resp).arrayBuffer();
                return await WebAssembly.instantiate(source, importObject);
            };
        }

        const go = new Go();
        // Set environment variables for the Go runtime.
        // LOGGER_FORCE_COLOR: force fortio.org/log to emit ANSI colors
        // COLORTERM: signal 24-bit color support (xterm.js supports truecolor)
        go.env = go.env || {};
        // go.env["LOGGER_FORCE_COLOR"] = "true";
        go.env["TERM"] = "xterm-256color"; // Ensure Go's term package enables color support
        go.env["COLORTERM"] = "truecolor";
        // go.env["LOGGER_JSON"] = "false"; // Disable JSON output since we're a terminal, not a structured log consumer.
        // go.env["LOGGER_IGNORE_CLI_MODE"] = "true"; // Disable fortio.org/log's CLI mode detection (which looks for isatty) since we're always a terminal here.

        WebAssembly.instantiateStreaming(fetch("/grol.wasm"), go.importObject).then((result) => {
            // Start Go runtime. main() registers JS functions then blocks on select{}.
            go.run(result.instance);

            // Update version display
            if (typeof grolVersion !== 'undefined') {
                document.getElementById('version').textContent = 'GROL ' + grolVersion;
            }

            // Start the interactive REPL goroutine.
            // It will read from os.Stdin (bridged above) and write to os.Stdout.
            // Terminal globals are already set, so fortio.org/terminal.IsTerminal()
            // returns true and repl.Interactive() works.
            grolStartREPL(xterm.cols, xterm.rows);

            xterm.focus();

            // Save state (history + variables) when the page is being closed.
            // grolSaveState calls terminal.SaveHistory() and repl.AutoSave()
            // which write to the localStorage-backed virtual filesystem.
            window.addEventListener('pagehide', () => {
                if (typeof grolSaveState === 'function') {
                    grolSaveState();
                }
            });
        }).catch((err) => {
            console.error('Failed to load WASM:', err);
            xterm.writeln('\x1b[31mFailed to load GROL WASM: ' + err.message + '\x1b[0m');
        });
    </script>
</body>

</html>
