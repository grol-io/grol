<!doctype html>
<html>
<!--
  xterm.js based interactive REPL for grol.
  Uses globalThis.fs overrides to bridge stdin/stdout/stderr between
  the Go WASM runtime and xterm.js. The Go side uses x/term.Terminal
  for line editing (ANSI escape sequences), which xterm.js renders.

  Keep grol/wasm/xterm.html and web-site/_includes/xterm.html in sync.
  make wasm to test changes.
-->

<head>
    <meta charset="utf-8">
    <title>Grol REPL</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5/css/xterm.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1e1e1e;
            color: #ccc;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #header {
            padding: 8px 12px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        #header a {
            color: #6cb6ff;
            text-decoration: none;
        }

        #header a:hover {
            text-decoration: underline;
        }

        #version {
            color: #888;
            font-size: 13px;
        }

        #status {
            color: #888;
            font-size: 13px;
            margin-left: auto;
        }

        #image-container {
            display: none;
            padding: 8px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            text-align: center;
            flex-shrink: 0;
            position: relative;
        }

        #image-container img {
            max-width: 100%;
            max-height: 300px;
        }

        #close-image {
            position: absolute;
            top: 4px;
            right: 8px;
            cursor: pointer;
            color: #888;
            font-size: 18px;
            background: none;
            border: none;
        }

        #close-image:hover {
            color: #fff;
        }

        #terminal-container {
            flex: 1;
            padding: 4px;
            overflow: hidden;
        }

        .xterm {
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="header">
        <span id="version">Loading GROL...</span>
        <a href="/index.html">Textarea mode</a>
        <span id="status"></span>
    </div>
    <div id="image-container">
        <button id="close-image" onclick="closeImage()">&times;</button>
        <img id="image" src="" alt="Image output">
    </div>
    <div id="terminal-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0/lib/addon-fit.js"></script>
    <script src="/wasm_exec.js"></script>
    <script>
        // ─── xterm.js Terminal Setup ─────────────────────────────────
        const xterm = new Terminal({
            cursorBlink: true,
            fontSize: 15,
            fontFamily: '"Cascadia Code", "Fira Code", "JetBrains Mono", Menlo, Monaco, "Courier New", monospace',
            theme: {
                background: '#1e1e1e',
                foreground: '#d4d4d4',
                cursor: '#d4d4d4',
                selectionBackground: '#264f78',
            },
            convertEol: false,  // We handle \r\n ourselves (x/term.Terminal does CRLF)
            allowProposedApi: true,
        });

        const fitAddon = new FitAddon.FitAddon();
        xterm.loadAddon(fitAddon);
        xterm.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        // Set terminal globals for fortio.org/terminal WASM detection.
        // These must be set before go.run() so IsTerminal() returns true.
        globalThis.TerminalConnected = true;
        globalThis.TerminalCols = xterm.cols;
        globalThis.TerminalRows = xterm.rows;

        window.addEventListener('resize', () => {
            fitAddon.fit();
            // Update globals for fortio.org/terminal's platformGetSize
            globalThis.TerminalCols = xterm.cols;
            globalThis.TerminalRows = xterm.rows;
            // Also notify Go directly if the function is registered
            if (typeof grolSetTermSize === 'function') {
                grolSetTermSize(xterm.cols, xterm.rows);
            }
        });

        function closeImage() {
            document.getElementById('image-container').style.display = 'none';
            fitAddon.fit();
        }

        // ─── STDIN/STDOUT/STDERR Bridge ──────────────────────────────
        //
        // The Go WASM runtime (wasm_exec.js) uses globalThis.fs for all
        // file I/O. By overriding read/write/writeSync, we bridge:
        //   - os.Stdout (fd=1) → xterm.write()
        //   - os.Stderr (fd=2) → xterm.write()
        //   - os.Stdin  (fd=0) ← xterm.onData()
        //
        // This lets x/term.Terminal (Go's line editor) work transparently:
        //   - It reads raw keystrokes from os.Stdin
        //   - It writes ANSI escape sequences to os.Stdout
        //   - xterm.js renders the escape sequences (cursor movement, etc.)

        // Stdin buffer: xterm.js onData → stdinBuf; Go fs.read(0) ← stdinBuf
        let stdinBuf = new Uint8Array(0);
        let pendingRead = null;  // {buffer, offset, length, callback} when Go is waiting for input

        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();

        function concatBytes(a, b) {
            const c = new Uint8Array(a.length + b.length);
            c.set(a, 0);
            c.set(b, a.length);
            return c;
        }

        // Feed raw bytes from xterm.js into the stdin buffer.
        // If Go is blocked on fs.read(0), immediately fulfill it.
        function feedStdin(data) {
            const encoded = textEncoder.encode(data);

            if (pendingRead) {
                const { buffer, offset, length, callback } = pendingRead;
                pendingRead = null;

                const n = Math.min(encoded.length, length);
                buffer.set(encoded.subarray(0, n), offset);

                // Buffer any leftover
                if (encoded.length > n) {
                    stdinBuf = concatBytes(stdinBuf, encoded.subarray(n));
                }

                // Resume the blocked Go goroutine
                callback(null, n);
            } else {
                // No pending read, buffer for later
                stdinBuf = concatBytes(stdinBuf, encoded);
            }
        }

        // Save originals before overriding
        const origFsRead = globalThis.fs.read.bind(globalThis.fs);
        const origFsWrite = globalThis.fs.write.bind(globalThis.fs);
        const origFsWriteSync = globalThis.fs.writeSync.bind(globalThis.fs);

        // Override fs.fstat: make fd 0,1,2 report as character devices.
        // Go's os.File.Stat() calls syscall.Fstat which calls globalThis.fs.fstat.
        // Go's log.ConsoleLogging() checks (Mode & ModeCharDevice) to decide
        // between console (color) vs JSON logging. Without this, WASM gets JSON.
        // S_IFCHR = 0o20000 = 8192. mode = S_IFCHR | 0o620 (owner rw, group w).
        const origFsFstat = globalThis.fs.fstat.bind(globalThis.fs);
        const S_IFCHR = 0o20000;
        const charDevMode = S_IFCHR | 0o620;
        const now = Date.now();
        globalThis.fs.fstat = function(fd, callback) {
            if (fd <= 2) {
                callback(null, {
                    dev: 0, ino: 0, mode: charDevMode, nlink: 1,
                    uid: 0, gid: 0, rdev: 0, size: 0,
                    blksize: 4096, blocks: 0,
                    atimeMs: now, mtimeMs: now, ctimeMs: now,
                    isDirectory() { return false; },
                });
                return;
            }
            origFsFstat(fd, callback);
        };

        // Override fs.read: bridge fd=0 (stdin) to xterm.js input buffer
        globalThis.fs.read = function(fd, buffer, offset, length, position, callback) {
            if (fd !== 0) {
                // Not stdin, use original (will likely return ENOSYS)
                origFsRead(fd, buffer, offset, length, position, callback);
                return;
            }

            if (stdinBuf.length > 0) {
                // Data available, return immediately
                const n = Math.min(stdinBuf.length, length);
                buffer.set(stdinBuf.subarray(0, n), offset);
                stdinBuf = stdinBuf.subarray(n);
                if (stdinBuf.length === 0) stdinBuf = new Uint8Array(0);
                callback(null, n);
            } else {
                // No data yet. Save the read request; feedStdin() will fulfill it.
                // This effectively suspends the Go goroutine until xterm.js sends input.
                pendingRead = { buffer, offset, length, callback };
            }
        };

        // Override fs.writeSync: bridge fd=1,2 (stdout/stderr) to xterm.js
        globalThis.fs.writeSync = function(fd, buf) {
            if (fd === 1 || fd === 2) {
                const text = textDecoder.decode(buf);
                // x/term.Terminal already sends \r\n, but other Go code (log, fmt.Println)
                // may only send \n. We normalize: replace bare \n with \r\n.
                // This regex leaves existing \r\n unchanged.
                const normalized = text.replace(/([^\r])\n/g, '$1\r\n').replace(/^\n/, '\r\n');
                xterm.write(normalized);

                // Check for data: URL images in output
                if (text.startsWith('data:image/')) {
                    const nl = text.indexOf('\n');
                    const dataUrl = nl >= 0 ? text.substring(0, nl) : text;
                    document.getElementById('image').src = dataUrl;
                    document.getElementById('image-container').style.display = 'block';
                    fitAddon.fit();
                }

                return buf.length;
            }
            return origFsWriteSync(fd, buf);
        };

        // Override fs.write (async version used by Go runtime)
        globalThis.fs.write = function(fd, buf, offset, length, position, callback) {
            if (fd === 1 || fd === 2) {
                if (offset !== 0 || length !== buf.length || position !== null) {
                    callback(new Error("unsupported write parameters"), 0);
                    return;
                }
                const n = this.writeSync(fd, buf);
                callback(null, n);
                return;
            }
            origFsWrite(fd, buf, offset, length, position, callback);
        };

        // ─── xterm.js Input → Go stdin ───────────────────────────────
        // xterm.js onData sends raw keystrokes (including ANSI escape
        // sequences for arrow keys, etc.) — exactly what x/term.Terminal
        // expects. No JS-side line editing needed!
        xterm.onData(data => {
            feedStdin(data);
        });

        // ─── WASM Initialization ─────────────────────────────────────
        if (!WebAssembly.instantiateStreaming) {
            WebAssembly.instantiateStreaming = async (resp, importObject) => {
                const source = await (await resp).arrayBuffer();
                return await WebAssembly.instantiate(source, importObject);
            };
        }

        const go = new Go();
        // Set environment variables for the Go runtime.
        // LOGGER_FORCE_COLOR: force fortio.org/log to emit ANSI colors
        // COLORTERM: signal 24-bit color support (xterm.js supports truecolor)
        go.env = go.env || {};
        // go.env["LOGGER_FORCE_COLOR"] = "true";
        go.env["TERM"] = "xterm-256color"; // Ensure Go's term package enables color support
        go.env["COLORTERM"] = "truecolor";
        // go.env["LOGGER_JSON"] = "false"; // Disable JSON output since we're a terminal, not a structured log consumer.
        // go.env["LOGGER_IGNORE_CLI_MODE"] = "true"; // Disable fortio.org/log's CLI mode detection (which looks for isatty) since we're always a terminal here.

        WebAssembly.instantiateStreaming(fetch("/grol.wasm"), go.importObject).then((result) => {
            // Start Go runtime. main() registers JS functions then blocks on select{}.
            go.run(result.instance);

            // Update version display
            if (typeof grolVersion !== 'undefined') {
                document.getElementById('version').textContent = 'GROL ' + grolVersion;
            }

            // Start the interactive REPL goroutine.
            // It will read from os.Stdin (bridged above) and write to os.Stdout.
            // Terminal globals are already set, so fortio.org/terminal.IsTerminal()
            // returns true and repl.Interactive() works.
            grolStartREPL(xterm.cols, xterm.rows);

            xterm.focus();
        }).catch((err) => {
            console.error('Failed to load WASM:', err);
            xterm.writeln('\x1b[31mFailed to load GROL WASM: ' + err.message + '\x1b[0m');
        });
    </script>
</body>

</html>
