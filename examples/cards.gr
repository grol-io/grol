// Rounded corner rectangle
func roundedRect(img, x, y, w, h, r) {
	image.move_to(img, x + r, y)
	image.line_to(img, x + w - r, y)
	image.quad_to(img, x + w, y, x + w, y + r)
	image.line_to(img, x + w, y + h - r)
	image.quad_to(img, x + w, y + h, x + w - r, y + h)
	image.line_to(img, x + r, y + h)
	image.quad_to(img, x, y + h, x, y + h - r)
	image.line_to(img, x, y + r)
	image.quad_to(img, x, y, x + r, y)
	image.close_path(img)
}

// Draw a simple-ish heart
func simpleHeartPath(img, x, y, w, h) {
	centerX := x + w/2
	centerY := y + h/2
	image.move_to(img, centerX, y + h)
	image.cube_to(img,
		centerX - w/2, y + 2*h/3, // First control: out to the left
		centerX - w/3, y,         // Second control: sharp angle at top
		centerX, y + h/3          // End point: where curves meet
	)
	image.cube_to(img,
		centerX + w/3, y,         // First control: sharp angle at top
		centerX + w/2, y + 2*h/3, // Second control: out to the right
		centerX, y + h            // End point: back to bottom
	)
	image.close_path(img)
}

// Fancier heart shape based on SVG quadratic commands translated to grol.
// All Y coordinates will be flipped if upsideDown is true
func drawHeartPath(img, x, y, w, h, upsideDown) {
    x = round(x) + 0.5
    y = round(y) + 0.5
    // Scale factors, original svg was 20x20
    sx := w / 20.0
    sy := h / 20.0
    // Helper lambda to flip Y coordinates if upsideDown
    flipY := func(svgY) {
        if upsideDown {
            return (20.0 - svgY) * sy + y
        }
        return svgY * sy + y
    }
    // M10,6
    image.move_to(img, x + 10 * sx, flipY(6))
    // Q10,0 15,0
    image.quad_to(img, x + 10 * sx, flipY(0), x + 15 * sx, flipY(0))
    // Q20,0 20,6
    image.quad_to(img, x + 20 * sx, flipY(0), x + 20 * sx, flipY(6))
    // Q20,10 15,14
    image.quad_to(img, x + 20 * sx, flipY(10), x + 15 * sx, flipY(14))
    // Q10,18 10,20
    image.quad_to(img, x + 10 * sx, flipY(18), x + 10 * sx, flipY(20))
    // Q10,18 5,14
    image.quad_to(img, x + 10 * sx, flipY(18), x + 5 * sx, flipY(14))
    // Q0,10 0,6
    image.quad_to(img, x + 0, flipY(10), x + 0, flipY(6))
    // Q0,0 5,0
    image.quad_to(img, x + 0, flipY(0), x + 5 * sx, flipY(0))
    // Q10,0 10,6
    image.quad_to(img, x + 10 * sx, flipY(0), x + 10 * sx, flipY(6))
    image.close_path(img)
}

// Function to draw a filled heart
func drawHeart(img, x, y, w, h, color, upsideDown) {
    drawHeartPath(img, x, y, w, h, upsideDown)
    image.draw(img, color)
}

// Function to define the path for a diamond shape
func drawDiamondPath(img, x, y, w, h) {
    // Calculate center point
    centerX := x + w/2.0
    centerY := y + h/2.0
    // Points at top, right, bottom, left
    topX := centerX
    topY := y
    rightX := x + w
    rightY := centerY
    bottomX := centerX
    bottomY := y + h
    leftX := x
    leftY := centerY
    // Control points offset - same percentage for both directions
    offset := w * 0.2  // 20% of width for both horizontal and vertical offset
    // Draw the diamond shape with curves
    image.move_to(img, topX, topY)
    // Top right curve
    image.quad_to(img,
        topX + offset, rightY - offset,  // Control point moved inside
        rightX, rightY
    )
    // Bottom right curve
    image.quad_to(img,
        bottomX + offset, rightY + offset,  // Control point moved inside
        bottomX, bottomY
    )
    // Bottom left curve
    image.quad_to(img,
        bottomX - offset, leftY + offset,  // Control point moved inside
        leftX, leftY
    )
    // Top left curve
    image.quad_to(img,
        topX - offset, leftY - offset,  // Control point moved inside
        topX, topY
    )
    image.close_path(img)
}

// Function to draw a filled diamond
func drawDiamond(img, x, y, w, h, color) {
    // Adjust dimensions for better diamond proportions
    adjustedW := w * 0.85
    adjustedH := h * 1.1
    // Adjust x position to keep diamond centered with original width
    adjustedX := x + (w - adjustedW)/2
    adjustedY := y + (h - adjustedH)/2
    drawDiamondPath(img, adjustedX, adjustedY, adjustedW, adjustedH)
    image.draw(img, color)
}

// Function to draw a filled club
func drawClub(img, x, y, w, h, color, upsideDown) {
    if upsideDown {
        // If upside down, flip the y coordinate and drawing order
        y = y + h
        h = -h
    }
    // Scale factors
    sx := w / 20.0
    sy := h / 20.0
    // Circle radius (relative to width)
    radius := w * 0.23
    // Draw the three circles with adjusted spacing
    // Top circle
    centerX := x + w/2.0
    topY := y + h * 0.22
    drawDisc(img, centerX, topY, radius, color)
    // Bottom left circle - tighter spacing
    leftX := centerX - radius * 1.1
    bottomY := y + h * 0.56
    drawDisc(img, leftX, bottomY, radius, color)
    // Bottom right circle
    rightX := centerX + radius * 1.1
    drawDisc(img, rightX, bottomY, radius, color)
    // Draw stem below circles - even more pointed
    stemH := h * 0.675
    stemY := y + h * 0.335
    stemW := w * 0.3
    drawTriangle(img, centerX, stemY, stemW, stemH, color)
    // Draw a small rectangle to fill the gap
    rectW := w * 0.2
    rectH := h * 0.2
    rectX := x + (w-rectW)/2
    rectY := y + h * 0.31
    drawRect(img, rectX, rectY, rectW, rectH, color)
}

// Function to draw a filled spade
func drawSpade(img, x, y, w, h, color, upsideDown) {
    if upsideDown {
        // If upside down, flip the y coordinate and drawing order
        y = y + h
        h = -h
    }
    // Draw inverted heart for top part
    heartW := w
    heartH := h * 0.85
    drawHeartPath(img, x - (heartW - w)/2, y, heartW, heartH, true)  // Always true for spade (removed !upsideDown)
    image.draw(img, color)
    // Draw stem below heart
    stemH := h * 0.5
    stemY := y + heartH * 0.65
    drawTriangle(img,  x + w/2.0, stemY, w/3.0, stemH, color)
}

func discQuadrant(img, x, y, rx, ry, color) {
    x = round(x) + 0.5
    y = round(y) + 0.5
	a := 1.00005519
	b := 0.55342686
	c := 0.99873585
	p0x := x + rx*a
	p0y := y
	image.move_to(img, x, y)
	image.line_to(img, p0x, p0y)
	p2x := x + rx*b
	p2y := y + ry*c
	p1x := x + rx*c
	p1y := y + ry*b
	p3x := x
	p3y := y + ry*a
	image.cube_to(img, p1x, p1y, p2x, p2y, p3x, p3y)
	// image.line_to(img, x, y) // covered by close_path in draw
	image.draw(img, color)
}

// Function to draw a complete circle using discQuadrant
func drawDisc(img, x, y, radius, color) {
	// Draw all four quadrants to make a complete circle
	discQuadrant(img, x, y, radius, radius, color)  // Top-right quadrant
	discQuadrant(img, x, y, -radius, radius, color)  // Top-left quadrant
	discQuadrant(img, x, y, -radius, -radius, color)  // Bottom-left quadrant
	discQuadrant(img, x, y, radius, -radius, color)  // Bottom-right quadrant
}

// Function to draw a simple filled rectangle
func drawRect(img, x, y, w, h, color) {
    image.move_to(img, x, y)
    image.line_to(img, x + w, y)
    image.line_to(img, x + w, y + h)
    image.line_to(img, x, y + h)
    image.close_path(img)
    image.draw(img, color)
}

// triangle with base centered on x,y
func drawTriangle(img, x, y, w, h, color) {
    image.move_to(img, x-w/2.0, y+h)
    image.line_to(img, x + w/2.0, y+h)
    image.line_to(img, x, y)
    image.close_path(img)
    image.draw(img, color)
}

// ---- text centering ---

// Helper function to return default if value is nil
func or(val, default_val) {
    if val == nil {
        return default_val
    }
    return val
}

// Function to center multi-line text at specified coordinates
func center_text(img, cx, cy, text, ..) {
    opts := ..[0] // var args to get last optional argument, which is a map if provided
    // Set defaults for optional parameters and override with any provided options
    size := or(opts.size, 18.)  // Default size
    color := or(opts.color, [0, 0, 0, 255])  // Default black
    variant := or(opts.variant, "regular")  // Default font
    spacing := or(opts.spacing, 1.)  // Default spacing

    // Split text into lines using Grol's split function
    lines := split(text, "\n")

    // Calculate total height with spacing using "Xg" for better height measurement
    lineHeight := image.text_size("Xg", size, variant).height
    spacedLineHeight := lineHeight * spacing
    totalHeight := spacedLineHeight * (len(lines) - 1) + lineHeight  // Last line doesn't need spacing

    // Start position for first line
    y := cy - totalHeight/2 + lineHeight/2

    // Draw each line centered
    for line := lines {
        textSize := image.text_size(line, size, variant)
        x := cx - textSize.width/2
        image.text(img, x, y, size, line, color, variant)
        y = y + spacedLineHeight
    }
}
// ---- text centering ---

// Create a new image
cardW := 300.0  // Larger card width
cardH := 400.0  // Larger card height
margin := 20.0  // Margin between cards and edges
suitSize := 60.0  // Base suit size
suitMargin := 25.0  // Reduced margin for suits within cards

// Calculate total width and height needed
w := 2.0 * cardW + 3.0 * margin  // Two cards wide plus margins
h := 2.0 * cardH + 3.0 * margin  // Two cards tall plus margins
img = image.new("myimg", round(w), round(h))

// Draw four cards in 2x2 grid
for i := 4 {
    // Calculate card position (2x2 grid)
    row := i / 2  // 0 for top row, 1 for bottom row
    col := i % 2  // 0 for left column, 1 for right column
    cardX := margin + col * (cardW + margin)
    cardY := margin + row * (cardH + margin)

    // Draw card background
    roundedRect(img, cardX, cardY, cardW, cardH, 10)
    image.draw(img, [255, 255, 255])

    // Calculate suit positions
    topLeftX := cardX + suitMargin
    topLeftY := cardY + suitMargin
    bottomRightX := cardX + cardW - suitMargin - suitSize
    bottomRightY := cardY + cardH - suitMargin - suitSize

    // Draw suits based on card index
    if i == 0 {
        // Hearts
        drawHeart(img, topLeftX, topLeftY, suitSize, suitSize, [255, 0, 0], false)
        drawHeart(img, bottomRightX, bottomRightY, suitSize, suitSize, [255, 0, 0], true)
    } else if i == 1 {
        // Spades
        drawSpade(img, topLeftX, topLeftY, suitSize, suitSize, [0, 0, 0], false)
        drawSpade(img, bottomRightX, bottomRightY, suitSize, suitSize, [0, 0, 0], true)
    } else if i == 2 {
        // Clubs
        drawClub(img, topLeftX, topLeftY, suitSize, suitSize, [0, 0, 0], false)
        drawClub(img, bottomRightX, bottomRightY, suitSize, suitSize, [0, 0, 0], true)
    } else {
        // Diamonds
        drawDiamond(img, topLeftX, topLeftY, suitSize, suitSize, [255, 0, 0])
        drawDiamond(img, bottomRightX, bottomRightY, suitSize, suitSize, [255, 0, 0])
    }
}

// simple heart
simpleHeartPath(img, w/2-6*margin, h/2-6*margin, 12*margin, 10*margin)
image.draw(img, [255, 165, 0, 128])

// Draw centered multi-line text with options
center_text(img, w/2, h/2, "Semi\ntransparent\nitalic green\nhuge text", {
	    "size": 52,
	    "color": [0, 255, 0, 128],
	    "variant": "italic",
	})

center_text(img, w/2, h/2, "purple", {
	    "size": 52,
	    "color": [255, 0, 255, 200],
	    "variant": "bold"
	})

center_text(img, w/2, h/2, "defaults")


// Save to grol.png
image.save(img)

println("Cards with suits saved to grol.png")
